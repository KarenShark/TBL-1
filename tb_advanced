`timescale 1ns/1ps

module tb_extra;
  import polar_common_pkg::*;

  // clock/reset
  logic clk = 0;
  always #5 clk = ~clk;   // 100MHz

  logic rst_n;

  // DUT I/O
  logic        start_e;
  logic [23:0] data_in;
  logic        done_e;
  logic [63:0] codeword;

  logic        start_d;
  logic [63:0] rx;
  logic        done_d;
  logic [23:0] data_out;
  logic        valid;

  polar64_crc16_encoder u_enc (
    .clk(clk), .rst_n(rst_n),
    .start(start_e), .data_in(data_in),
    .done(done_e), .codeword(codeword)
  );

  polar64_crc16_decoder u_dec (
    .clk(clk), .rst_n(rst_n),
    .start(start_d), .rx(rx),
    .done(done_d), .data_out(data_out), .valid(valid)
  );

  // ------------ helpers ------------
  function automatic int popcount64(input logic [63:0] x);
    int c, i;
    begin
      c = 0;
      for (i=0; i<64; i++) if (x[i]) c++;
      return c;
    end
  endfunction

  // random mask with exact weight w
  function automatic logic [63:0] rand_mask_w(input int w, inout int unsigned seed);
    logic [63:0] m;
    int cnt, idx;
    begin
      m = 64'b0;
      cnt = 0;
      while (cnt < w) begin
        idx = $urandom(seed) % 64;
        if (!m[idx]) begin
          m[idx] = 1'b1;
          cnt++;
        end
      end
      return m;
    end
  endfunction

  task automatic apply_reset();
    begin
      rst_n   = 0;
      start_e = 0;
      start_d = 0;
      data_in = '0;
      rx      = '0;
      repeat(5) @(posedge clk);
      rst_n = 1;
      repeat(2) @(posedge clk);
    end
  endtask

  // start a 1-cycle pulse; optionally keep high for extra cycles
  task automatic pulse_start(input bit is_enc, input int hold_cycles);
    int k;
    begin
      if (is_enc) start_e = 1; else start_d = 1;
      @(posedge clk);
      for (k=0; k<hold_cycles; k++) @(posedge clk);
      if (is_enc) start_e = 0; else start_d = 0;
    end
  endtask

  // expect encoder done exactly +2 cycles, 1-cycle pulse
  task automatic enc_check_timing(input int start_cycle, input int done_cycle);
    begin
      if (done_cycle != start_cycle + 2) $fatal(1, "[ENC] done not at +2 cycles: start=%0d done=%0d", start_cycle, done_cycle);
    end
  endtask

  // expect decoder done <=12, 1-cycle pulse
  task automatic dec_check_timing(input int start_cycle, input int done_cycle);
    begin
      if (done_cycle > start_cycle + 12) $fatal(1, "[DEC] done too late: start=%0d done=%0d", start_cycle, done_cycle);
    end
  endtask

  // run one encode transaction, returns codeword
  task automatic do_encode(input logic [23:0] din, output logic [63:0] cw,
                           input int hold_start_cycles = 0);
    int cyc_start, cyc_done;
    begin
      data_in = din;
      // capture cycle count
      cyc_start = $time/10; // since clk period=10ns (粗略计cycle)
      pulse_start(1'b1, hold_start_cycles);

      // wait done, also ensure it's a 1-cycle pulse
      wait(done_e === 1'b1);
      cyc_done = $time/10;
      cw = codeword;

      // done should drop next cycle
      @(posedge clk);
      if (done_e !== 1'b0) $fatal(1, "[ENC] done not 1-cycle pulse");

      enc_check_timing(cyc_start, cyc_done);
    end
  endtask

  // run one decode transaction, returns valid/data_out
  task automatic do_decode(input logic [63:0] rx_in, output logic v, output logic [23:0] dout,
                           input int hold_start_cycles = 0);
    int cyc_start, cyc_done;
    begin
      rx = rx_in;
      cyc_start = $time/10;
      pulse_start(1'b0, hold_start_cycles);

      wait(done_d === 1'b1);
      cyc_done = $time/10;
      v    = valid;
      dout = data_out;

      @(posedge clk);
      if (done_d !== 1'b0) $fatal(1, "[DEC] done not 1-cycle pulse");

      dec_check_timing(cyc_start, cyc_done);
    end
  endtask

  // ------------ main tests ------------
  int unsigned seed = 32'hC0FFEE01;

  initial begin
    apply_reset();

    // sanity: position tables should be OK if tb expects it
    if (!pos_tables_ok()) $fatal(1, "pos tables invalid!");

    // 1) Random functional tests: 0..4 bit errors
    automatic int t;
    for (t=0; t<500; t++) begin
      logic [23:0] din;
      logic [63:0] cw, m;
      logic v;
      logic [23:0] dout;

      din = $urandom(seed);

      // sometimes hold start high extra cycles (stress)
      do_encode(din, cw, (t%50==0)?2:0);

      // weight 0
      do_decode(cw, v, dout);
      if (!(v && dout==din)) $fatal(1, "[RND w0] fail din=%h dout=%h v=%0d", din, dout, v);

      // weight 1..3 must correct
      for (int w=1; w<=3; w++) begin
        m = rand_mask_w(w, seed);
        do_decode(cw ^ m, v, dout);
        if (!(v && dout==din)) $fatal(1, "[RND w%0d] fail din=%h dout=%h v=%0d mask=%h", w, din, dout, v, m);
      end

      // weight 4 must be invalid (fail-safe)
      m = rand_mask_w(4, seed);
      do_decode(cw ^ m, v, dout);
      if (v) $fatal(1, "[RND w4] should be invalid but valid=1 din=%h dout=%h mask=%h", din, dout, m);

      // occasionally reset mid-stream
      if (t%120==0) begin
        rst_n = 0;
        repeat(2) @(posedge clk);
        rst_n = 1;
        repeat(2) @(posedge clk);
      end
    end

    // 2) Busy/start abuse: try asserting start while busy
    begin
      logic [63:0] cw;
      logic [23:0] din = 24'h123456;
      data_in = din;
      start_e = 1;
      @(posedge clk);
      // keep start high while busy should not create multiple done pulses
      repeat(5) @(posedge clk);
      start_e = 0;

      // count done pulses
      int pulses = 0;
      repeat(10) begin
        @(posedge clk);
        if (done_e) pulses++;
      end
      if (pulses != 1) $fatal(1, "[ENC] multiple done pulses under held start: %0d", pulses);
      cw = codeword;

      // decode should still work
      logic v; logic [23:0] dout;
      do_decode(cw, v, dout);
      if (!(v && dout==din)) $fatal(1, "[BUSY] decode fail");
    end

    // 3) Ambiguity search: find two codewords within distance <=6, craft rx with 2 hits -> valid must be 0
    begin
      typedef struct packed { logic [23:0] d; logic [63:0] c; } pair_t;
      pair_t vec [0:799]; // store 800 codewords
      int n = 800;

      // generate a pool
      for (int i=0; i<n; i++) begin
        logic [63:0] cw;
        vec[i].d = $urandom(seed);
        do_encode(vec[i].d, cw);
        vec[i].c = cw;
      end

      bit found = 0;
      logic [63:0] c1, c2, rx_amb;
      logic [23:0] d1, d2;

      for (int i=0; i<n && !found; i++) begin
        for (int j=i+1; j<n && !found; j++) begin
          int dist = popcount64(vec[i].c ^ vec[j].c);
          if (dist <= 6) begin
            c1 = vec[i].c; d1 = vec[i].d;
            c2 = vec[j].c; d2 = vec[j].d;

            // try craft rx as c1 with 3 flips that is also within 3 of c2
            for (int tries=0; tries<200 && !found; tries++) begin
              logic [63:0] m = rand_mask_w(3, seed);
              rx_amb = c1 ^ m;
              if (popcount64(rx_amb ^ c2) <= 3) found = 1;
            end
          end
        end
      end

      if (found) begin
        logic v; logic [23:0] dout;
        do_decode(rx_amb, v, dout);
        if (v) $fatal(1, "[AMB] expected valid=0 for non-unique solution but got valid=1, dout=%h", dout);
      end else begin
        $display("[AMB] no close pair found in pool; increase n or tries if you want stronger coverage.");
      end
    end

    $display("tb_extra PASSED");
    $finish;
  end

endmodule
