`timescale 1ns/1ps

// tb_extended.sv
// Extended testbench for Polar(64,40)+CRC-16 project
// Includes multiple data patterns and random error injections (0-5 bits)
// Maintains original timing checks

module tb_extended;

  import polar_common_pkg::*;

  logic clk;
  logic rst_n;

  // Encoder DUT ports
  logic        enc_start, enc_done;
  logic [23:0] data_in;
  logic [63:0] codeword;

  // Decoder DUT ports
  logic        dec_start, dec_done;
  logic [63:0] rx;
  logic [23:0] data_out;
  logic        valid;

  // Test control
  int total_tests = 0;
  int pass_tests  = 0;
  int fail_tests  = 0;
  int error_count = 0;          // 累计错误注入失败的次数（用于调试）

  // Clock generation
  initial clk = 1'b0;
  always #5 clk = ~clk;

  // DUT instances
  polar64_crc16_encoder u_enc (
    .clk(clk), .rst_n(rst_n),
    .start(enc_start), .data_in(data_in),
    .done(enc_done), .codeword(codeword)
  );

  polar64_crc16_decoder u_dec (
    .clk(clk), .rst_n(rst_n),
    .start(dec_start), .rx(rx),
    .done(dec_done), .data_out(data_out), .valid(valid)
  );

  // Helper: generate 1-cycle start pulse
  task automatic pulse_start(ref logic s);
    @(negedge clk);
    s = 1'b1;
    @(negedge clk);
    s = 1'b0;
  endtask

  // Helper: encode with timing check (same as before)
  task automatic do_encode(
    input  logic [23:0] din,
    output logic [63:0] cw,
    output logic        timing_ok
  );
    timing_ok = 1'b1;
    data_in   = din;
    pulse_start(enc_start);

    @(posedge clk); @(negedge clk);
    if (enc_done) timing_ok = 1'b0;

    @(posedge clk); @(negedge clk);
    if (!enc_done) timing_ok = 1'b0;

    cw = codeword;

    @(posedge clk); @(negedge clk);
    if (enc_done) timing_ok = 1'b0;
  endtask

  // Helper: decode with timing check (within 12 cycles)
  task automatic do_decode(
    input  logic [63:0] rx_in,
    output logic [23:0] dout,
    output logic        v,
    output int unsigned lat,
    output logic        timing_ok
  );
    timing_ok = 1'b1;
    lat       = 0;
    rx        = rx_in;
    pulse_start(dec_start);

    fork
      begin
        while (1) begin
          @(posedge clk); lat++;
          @(negedge clk);
          if (dec_done) break;
          if (lat >= 12) begin
            timing_ok = 1'b0;
            break;
          end
        end
      end
    join

    dout = data_out;
    v    = valid;

    if (timing_ok) begin
      @(posedge clk); @(negedge clk);
      if (dec_done) timing_ok = 1'b0;
    end
  endtask

  // Bit mask function
  function automatic logic [63:0] bit_mask(input int unsigned b);
    logic [63:0] m = 64'b0;
    m[b] = 1'b1;
    return m;
  endfunction

  // Random error pattern generator
  function automatic logic [63:0] random_error_pattern(input int num_bits);
    logic [63:0] pat = 64'b0;
    int          pos;
    for (int i = 0; i < num_bits; i++) begin
      pos = $urandom_range(0, 63);
      pat[pos] = 1'b1;  // 可能重复，但无妨
    end
    return pat;
  endfunction

  // Test one data value with various error injections
  task automatic test_one_data(input logic [23:0] test_data);
    logic [63:0] cw_ref, cw_dut;
    logic        enc_timing_ok;
    logic [23:0] dec_out;
    logic        dec_valid;
    int unsigned lat;
    logic        dec_timing_ok;
    logic [63:0] err_pat;
    string       msg;

    // 1. Encode
    do_encode(test_data, cw_dut, enc_timing_ok);
    if (!enc_timing_ok) begin
      $display("ERROR: Encoder timing failed for data %h", test_data);
      fail_tests++;
      return;
    end

    // Compute reference codeword using package functions
    cw_ref = polar_transform(build_u(test_data, crc16_ccitt(test_data)));

    if (cw_dut !== cw_ref) begin
      $display("ERROR: Encoder output mismatch for data %h", test_data);
      $display("  DUT: %h", cw_dut);
      $display("  REF: %h", cw_ref);
      fail_tests++;
      return;
    end

    // 2. Test with 0 errors
    do_decode(cw_ref, dec_out, dec_valid, lat, dec_timing_ok);
    total_tests++;
    if (!dec_timing_ok) begin
      $display("ERROR: Decoder timing failed (0 errors) for data %h", test_data);
      fail_tests++;
    end else if (dec_valid !== 1'b1 || dec_out !== test_data) begin
      $display("ERROR: Decoder 0-error case failed for data %h", test_data);
      $display("  valid: %b, data_out: %h", dec_valid, dec_out);
      fail_tests++;
    end else begin
      pass_tests++;
    end

    // 3. Test with 1-3 errors (random patterns)
    for (int e = 1; e <= 3; e++) begin
      // 尝试 5 个随机模式（可以调整数量）
      for (int trial = 0; trial < 5; trial++) begin
        err_pat = random_error_pattern(e);
        do_decode(cw_ref ^ err_pat, dec_out, dec_valid, lat, dec_timing_ok);
        total_tests++;
        if (!dec_timing_ok) begin
          $display("ERROR: Decoder timing failed (%0d errors, pat %h) for data %h", e, err_pat, test_data);
          fail_tests++;
        end else if (dec_valid !== 1'b1 || dec_out !== test_data) begin
          $display("ERROR: Decoder %0d-error case failed for data %h, pat %h", e, test_data, err_pat);
          $display("  valid: %b, data_out: %h", dec_valid, dec_out);
          fail_tests++;
        end else begin
          pass_tests++;
        end
      end
    end

    // 4. Test with 4 errors (must reject) – 随机尝试 5 个模式
    for (int trial = 0; trial < 5; trial++) begin
      err_pat = random_error_pattern(4);
      do_decode(cw_ref ^ err_pat, dec_out, dec_valid, lat, dec_timing_ok);
      total_tests++;
      if (!dec_timing_ok) begin
        $display("ERROR: Decoder timing failed (4 errors, pat %h) for data %h", err_pat, test_data);
        fail_tests++;
      end else if (dec_valid !== 1'b0) begin
        $display("ERROR: Decoder 4-error case should reject but valid=1 for data %h, pat %h", test_data, err_pat);
        $display("  data_out: %h", dec_out);
        fail_tests++;
      end else begin
        pass_tests++;
      end
    end

    // 5. Test with 5 errors (fail-safe: if valid=1 then data must be correct)
    for (int trial = 0; trial < 5; trial++) begin
      err_pat = random_error_pattern(5);
      do_decode(cw_ref ^ err_pat, dec_out, dec_valid, lat, dec_timing_ok);
      total_tests++;
      if (!dec_timing_ok) begin
        $display("ERROR: Decoder timing failed (5 errors, pat %h) for data %h", err_pat, test_data);
        fail_tests++;
      end else if (dec_valid === 1'b1 && dec_out !== test_data) begin
        $display("ERROR: Decoder 5-error case: valid=1 but data wrong for data %h, pat %h", test_data, err_pat);
        $display("  data_out: %h", dec_out);
        fail_tests++;
      end else begin
        pass_tests++;
      end
    end
  endtask

  // Test data list (you can add more)
  logic [23:0] test_data_list [];
  initial begin
    // Define a set of test data
    test_data_list = new[10];
    test_data_list = '{
      24'h000000,
      24'hFFFFFF,
      24'h123456,
      24'hABCDEF,
      24'hDEADBE,
      24'hCAFE12,
      24'h987654,
      24'h012345,
      24'hAAAAAA,
      24'h555555
    };
  end

  // Main test process
  initial begin
    enc_start = 1'b0;
    dec_start = 1'b0;
    data_in   = '0;
    rx        = '0;

    // Reset
    rst_n = 1'b0;
    repeat (5) @(posedge clk);
    rst_n = 1'b1;
    repeat (2) @(posedge clk);

    $display("============================================================");
    $display(" Extended Testbench for Polar(64,40)+CRC-16");
    $display("============================================================");

    // Loop through all test data
    foreach (test_data_list[i]) begin
      $display("Testing data[%0d] = %h", i, test_data_list[i]);
      test_one_data(test_data_list[i]);
    end

    $display("============================================================");
    $display(" Test Summary: %0d total, %0d passed, %0d failed", total_tests, pass_tests, fail_tests);
    $display("============================================================");

    if (fail_tests == 0) begin
      $display("All extended tests PASSED. This increases confidence but does not guarantee hidden test pass.");
      $finish;
    end else begin
      $display("Some tests FAILED. Please debug.");
      $fatal(1);
    end
  end

endmodule
